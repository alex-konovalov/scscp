<!-- $Id$ -->

<Chapter Label="Server">
<Heading>Running SCSCP server</Heading>    

<Section Label="InstallProcedures">
<Heading>Installing procedures</Heading>

<ManSection>
   <Func Name="InstallSCSCPprocedure" 
          Arg="procname procfunc [, description ] [, narg1 [, narg2 ] [, signature ] ]"
         Comm="" />
   <Returns>
     Nothing
   </Returns>	 
   <Description>
     For a string <A>procname</A> and a function <A>procfunc</A>, 
     <Ref Func="InstallSCSCPprocedure" /> makes the <A>procfunc</A> 
     available as SCSCP procedure under the name <A>procname</A>.
     <P/>
     The second argument <A>procfunc</A> maybe either standard or 
     user-defined function or procedure.
     <P/>
     The rest of arguments are optional and may be used in a number of combinations.
     <P/>
     <A>description</A> is a string with the description of the procedure, that may be used in the help system.<P/>
     <A>narg1</A> is a non-negative integer, specifying the minimal number of arguments.<P/>
     <A>narg2</A> is a non-negative integer or infinity, specifying the maximal number of arguments.
     If <A>narg2</A> is omitted then the maximal number of arguments will be set to <A>narg1</A>.<P/>
     <A>signature</A> is the signature record of the procedure. 
     It requires at least the minimal number of arguments to be specified.<P/>
     If optional arguments are not specified, they will be set to their default values.
     <!-- TODO: document default values , say what is transient CD -->
   </Description>
</ManSection>

In the following example we define the function <C>FactorialAsString</C>
that takes an integers and returns its factorial in the form of a string.
This allows correct handling of the case when the result is displayed as
an integer too large to be printed.

<Example>
<![CDATA[
gap> FactorialAsString := x -> String(Factorial( x ) );
function( x ) ... end
gap> InstallSCSCPprocedure( "WS_factorial", FactorialAsString );
InstallSCSCPprocedure : procedure WS_factorial installed. 
]]>
</Example>

Some examples with various combinations of some optional arguments are shown below:
<Example>
<![CDATA[
InstallSCSCPprocedure( "Factorial", Factorial, "See ?Factorial in GAP", 1, 1 );
InstallSCSCPprocedure( "WS_factorial", FactorialAsString, 
                       "Returns result as a string to transmit large integers", 1 );
InstallSCSCPprocedure( "GroupIdentificationService", 
                        IdGroupByGenerators, 1, infinity, rec() );
InstallSCSCPprocedure( "IdGroup512ByCode", IdGroup512ByCode, 1 );
InstallSCSCPprocedure( "WS_IdGroup", IdGroup, "See ?IdGroup in GAP" );
]]>
</Example>

The user is able to reinstall SCSCP procedures: 

<Example>
<![CDATA[
gap> InstallSCSCPprocedure( "WS_factorial", FactorialAsString );
WS_factorial is already installed. Do you want to reinstall it [y/n]? y
InstallSCSCPprocedure : procedure WS_factorial reinstalled. 
]]>
</Example>

In the following example we install the procedure that will accept a list
of permutations and return the number in the &GAP; Small Groups library
of the group they generate (for the sake of simplicity we omit tests of
validity of arguments, availablity of <C>IdGroup</C> for groups of given order
etc.)

<Example>
<![CDATA[
gap> IdGroupByGenerators:=function( permlist )
> return IdGroup( Group( permlist ) );
> end;
function( permlist ) ... end
gap> InstallSCSCPprocedure( "GroupIdentificationService", IdGroupByGenerators );
InstallSCSCPprocedure : procedure GroupIdentificationService installed. 
]]>
</Example>

Some more examples of installation of SCSCP procedures 
are given in the file <File>scscp/example/myserver.g</File>. 

<ManSection>
    <Var Name="OMsymRecord"
      Comm="" />
    <Description>
    <!-- TODO: write this --> 
   </Description>
</ManSection>


<ManSection>
    <Var Name="SCSCPtransientCDs"
      Comm="" />
    <Description>
    <!-- TODO: write this --> 
   </Description>
</ManSection>


</Section>

<Section Label="RunServer">
<Heading>Starting SCSCP server</Heading>

<ManSection>
   <Func Name="RunSCSCPserver" 
         Arg="server port"
         Comm="" />
   <Returns>
     Nothing
   </Returns>	 
   <Description>
     For a server hostname, given as a string <A>server</A> and
     an integer <A>port</A> specifying the port number,
     starts SCSCP server at <C>server</C>:<C>port</C>. 
     <!-- TODO: write that first argument may be true/false -->     
   </Description>
</ManSection>

<Example>
<![CDATA[
gap> RunSCSCPserver( "localhost", 26133 );
Ready to accept TCP/IP connections at localhost:26133 ...
Waiting for new client connection at localhost:26133 ...
]]>
</Example>

It is assumed that the service provider will write the server
configuration file, and will be able to start the SCSCP server
launching &GAP; e.g. with the command <C>gap myserver.g</C>. An example
of such configuration file is given in <File>scscp/example/myserver.g</File>. 

<!-- TODO: describe the gapd.sh script -->     

</Section>

<Section Label="SpecialProcedures">
<Heading>Procedures to get information about the &SCSCP; server</Heading>

<ManSection>
   <Func Name="GetServiceDescription" 
         Arg="server port"
         Comm="" />
   <Returns>
    record 
   </Returns>	 
   <Description>
    Returns the record with three components containing strings with the
    name, version and description of the service as specified by the 
    service provider in the <File>scscp/config.g</File> (for details
    about configuration files, see <Ref Label="Config" />).
<Example>
<![CDATA[
gap> GetServiceDescription("localhost",26133);
rec( service_name := "GAP SCSCP service", 
  version := "GAP 4.4.12 + SCSCP 1.1 started on Tue 21 Apr 2009 00:35:38 BST", 
  description := "Started with scscp/example/myserver.g from SCSCP 1.1" )
]]>
</Example>    
   </Description>
</ManSection>

<ManSection>
   <Func Name="GetAllowedHeads" 
         Arg="server port"
         Comm="" />
   <Returns>
    ??? list of records ???
    <!-- TODO : why not to return the structure like OMsymRecord ??? -->
   </Returns>	 
   <Description>
<!-- TODO: Should we return scscp{1,2} here>? Maybe we should return only transient CD? -->
<!-- TODO: Also, not all symbols are applications. Any thoughts ? What about using meta.Role ? -->
<Log>
<![CDATA[
gap> GetAllowedHeads("localhost",26133);
[ rec( name := "one", cd := "alg1" ), 
  rec( name := "zero", cd := "alg1" ), 
  rec( name := "abs", cd := "arith1" ), 
  rec( name := "divide", cd := "arith1" ), 
  rec( name := "gcd", cd := "arith1" ), 
  ...
  rec( name := "subgroup", cd := "group1" ), 
  rec( name := "group_by_generators", cd := "group1" ),
  ...
  rec( name := "WS_Factorial", cd := "scscp_transient_1" ), 
  rec( name := "WS_Phi", cd := "scscp_transient_1" ), 
  rec( name := "GroupIdentificationService", cd := "scscp_transient_1" ), 
  rec( name := "IdGroup512ByCode", cd := "scscp_transient_1" ), 
  rec( name := "WS_IdGroup", cd := "scscp_transient_1" ), 
...
  rec( name := "SCSCPStartTracing", cd := "scscp_transient_1" ), 
  rec( name := "SCSCPStopTracing", cd := "scscp_transient_1" ) ]
]]>
</Log>    
   </Description>
</ManSection>

<ManSection>
   <Func Name="IsAllowedHead" 
         Arg="cd symbol server port"
         Comm="" />
   <Returns>
    ???
   </Returns>	 
   <Description>
<!-- TODO: document this: -->
Note that no actual check whether cd/name exists!
<!-- TODO: since we store CD symbols, we may actually check this to avoid misprinting errors in symbol names! -->
<Example>
<![CDATA[
gap> IsAllowedHead("permgp1","group","localhost",26133);                            
true
gap> IsAllowedHead("nums1","pi","localhost",26133);          
false
]]>
</Example>  
   </Description> 
</ManSection>

<ManSection>
   <Func Name="GetTransientCD" 
         Arg="cd server port"
         Comm="" />
   <Returns>
    record
   </Returns>	 
   <Description>
    <!-- TODO: document this: -->
<Example>
<![CDATA[
gap> GetTransientCD( "scscp_transient_1", "localhost", 26133 );
rec( 
  Description := "This is a transient content dictionary containing information about procedures offer\
ed by the GAP SCSCP service", 
  CDName := "scscp_transient_1", 
  CDReviewDate := "2009-04-21", 
  CDDate := "2009-04-21", 
  CDVersion := "0", 
  CDRevision := "0", 
  CDStatus := "private", 
  CDDefinitions := 
    [ rec( Name := "WS_Factorial", Description := "See ?Factorial in GAP" ), 
      rec( Name := "WS_Phi", Description := "Euler's totient function, see ?Phi in GAP" ), 
  ...
      rec( Name := "SCSCPStartTracing", Description := "To turn on tracing mode on the server and save\
          events to specified filename without extensions" ), 
      rec( Name := "SCSCPStopTracing", Description := "To turn off tracing mode on the server" ) ] )
]]>
</Example>    
   </Description>
</ManSection>

<ManSection>
   <Func Name="GetSignature" 
         Arg="cd symbol server port"
         Comm="" />
   <Returns>
    record
   </Returns>	 
   <Description>
    <!-- TODO: document this: -->
<Example>
<![CDATA[
gap> GetSignature("scscp_transient_1","WS_Factorial","localhost",26133);                               
rec( symbol := rec( name := "WS_Factorial", cd := "scscp_transient_1" ), minarg := 1, maxarg := 1, 
  symbolargs := rec( name := "symbol_set_all", cd := "scscp2" ) )
]]>
</Example>    
   </Description>
</ManSection>

</Section>

</Chapter>