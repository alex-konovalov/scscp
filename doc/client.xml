<!-- $Id$ -->

<Chapter Label="ClientFunctionality">
<Heading>Client's functionality</Heading>    

<Section Label="Client">
<Heading>Sending request and getting result</Heading>

<ManSection>
    <Filt Name="IsProcess" />
    <Description>
    This is the category of processes. Process is an abstraction 
    which encapsulates an <C>InputOutputTCPStream</C>
    (see <Ref Filt="IsInputOutputTCPStream" /> from a client to the 
    server and the process ID which the server CAS has (deduced
    from the connection initiation message, may be not assigned,
    if the server CAS did not communicate it). Knowledge of the
    process ID on the server may be useful to send <Q>out-of-band</Q>
    interrupt messages.
    Processes in the category <Ref Filt="IsProcess" />
    are created using the function <Ref Func="NewProcess" />.
    </Description>
</ManSection>

<!-- TODO: Put notes on ResetOptionsStack() or restore OnQuit; -->

<ManSection>
   <Func Name="NewProcess" 
          Arg="command listargs server port"
         Comm="" />
   <Returns>
     object in the category <C>IsProcess</C>
   </Returns>	 
   <Description>
     <A>command</A> and <C>server</C> are strings, <A>listargs</A>
     is a list of &GAP; objects and <C>port</C> is an integer.
     Calls the &SCSCP; procedure with the name <A>command</A> 
     and the list of arguments <A>listargs</A> at the server and port
     given by <C>server</C> and <C>port</C>. Returns an object in
     the category <C>IsProcess</C> for the subsequent
     waiting the result from its underlying stream.
     <P/>
     It accepts the following options:
     <List>
     <Item> 
     <C>output:="object"</C> is the default action, the resulting object will
     be returned even if this option is omitted.
     </Item>
     <Item>
     <C>output:="cookie"</C>
         is used to specify that the result of the 
         procedure call should be stored on the server, and the
         server should return a remote object (see <Ref Sect="Remote" /> )
         pointing to that result (that is, a cookie);
     </Item>
     <Item>
     <C>output:="nothing"</C> is used to specify that the server is supposed to reply 
         with a <C>procedure_completed</C> message carrying no
         object just to signal that the call was completed successfully
         (for the compatibility, this will be signalled as "procedure completed" 
         string on the client's side)
     </Item>
     <Item>
     <C>cd:="cdname"</C> is used to specify that the &OpenMath; symbol corresponding
         to the first argument <A>command</A> should be looked up in the particular content
         dictionary <C>cdname</C>.
     </Item>
     <Item>
     <C>debuglevel:=N</C> is used to obtain additional information attributes together 
         with the result: if <C>N=1</C>, it will report about the CPU time in milliseconds
         required to compute the result; if <C>N=2</C> it will additionally report about
         the amount of memory used by &GAP; in bytes will be returned
         (using the output of <Ref Func="MemoryUsageByGAPinKbytes" /> converted to bytes);
         if <C>N=3</C> it will additionally report the amount of memory in bytes used by 
         the resulting object and its subobjects (using the output of 
         <Ref BookName="ref" Oper="MemoryUsage" />).
     </Item>
     </List>
     See <Ref Func="CompleteProcess" /> and <Ref Func="EvaluateBySCSCP" /> for examples.
   </Description>
</ManSection>

<ManSection>
   <Func Name="CompleteProcess" 
          Arg="process"
         Comm="" />
   <Returns>
     record with components <C>object</C> and <C>attributes</C> 
   </Returns>	 
   <Description>
     The function waits, if necessary, until the underlying stream of the process 
     will contain some data, then reads appropriate &OpenMath; object from this stream
     and closes it.
     <P/>
     It has the option <C>output</C> which may have two values:
     <List>
     <Item> 
     <C>output:="cookie"</C> has the same meaning like for <Ref Func="NewProcess" />
     </Item>
     <Item>
     <C>output:="tree"</C> is used to specify that the result obtained from the
         server should be returned as an XML parsed tree without its evaluation.
     </Item>
     </List>
   </Description>
</ManSection>

In the following example we demonstrate combination of the two previous
functions to send request and get result, calling the procedure, installed 
in the previous chapter: 

<Example>
<![CDATA[
gap> s := NewProcess( "WS_factorial", [10], "localhost", 26133 );                  
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
< process at localhost:26133 pid=6543 >
gap> x := CompleteProcess(s);
rec( object := "3628800", attributes := [ [ "call_id", "localhost:26133:6543" ] ] )
]]>
</Example>

See more examples in the description of the function <Ref Func="EvaluateBySCSCP" />,
which combines the two previous functions by sending request and getting result in one call.

<ManSection>
   <Func Name="EvaluateBySCSCP" 
          Arg="command listargs server port"
         Comm="" />
   <Returns>
     record with components <C>object</C> and <C>attributes</C> 
   </Returns>	 
   <Description>
     <A>command</A> and <C>server</C> are strings, <A>listargs</A>
     is a list of &GAP; objects and <C>port</C> is an integer.
     Calls the SCSCP procedure with the name <A>command</A> 
     and the list of arguments <A>listargs</A> at the server and port
     given by <C>server</C> and <C>port</C>.
     <P/>
     Since <Ref Func="EvaluateBySCSCP" /> combines <Ref Func="NewProcess" /> 
     and <Ref Func="CompleteProcess" />, it has all options which may be
     used by that functions ( <C>output</C>, <C>cd</C> and 
     <C>debuglevel</C>  ) with the same meanings.

<Example>
<![CDATA[
gap> EvaluateBySCSCP( "WS_Factorial",[10],"localhost",26133);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message
#I  Requesting version 1.3 from the server ...
#I  Server confirmed version 1.3 to the client ...
#I  Request sent ...
#I  Waiting for reply ...
rec( attributes := [ [ "call_id", "localhost:26133:2442:6hMEN40d" ] ], 
     object := 3628800 )
gap> SetInfoLevel(InfoSCSCP,0);
gap> EvaluateBySCSCP( "WS_Factorial",[10],"localhost",26133 : output:="cookie" ); 
rec( attributes := [ [ "call_id", "localhost:26133:2442:jNQG6rml" ] ], 
  object := < remote object TEMPVarSCSCP@localhost:26133 > )
gap> EvaluateBySCSCP( "WS_Factorial",[10],"localhost",26133 : output:="nothing" );
rec( attributes := [ [ "call_id", "localhost:26133:2442:9QHQrCjv" ] ], 
  object := "procedure completed" )
]]>
</Example>

   </Description>
</ManSection>


Now we demonstrate the procedure <C>GroupIdentificationService</C>,
also given in the previous chapter:

<Example>
<![CDATA[
gap> G:=SymmetricGroup(4);
Sym( [ 1 .. 4 ] )
gap> gens:=GeneratorsOfGroup(G);
[ (1,2,3,4), (1,2) ]
gap> EvaluateBySCSCP( "GroupIdentificationService", [ gens ],
>                     "localhost", 26133 : debuglevel:=3 ); 
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message
#I  Requesting version 1.3 from the server ...
#I  Server confirmed version 1.3 to the client ...
#I  Request sent ...
#I  Waiting for reply ...
rec( attributes := [ [ "call_id", "localhost:26133:2442:xOilXtnw" ], 
      [ "info_runtime", 6 ], [ "info_memory", 670175232 ], 
      [ "info_message", "Memory usage for the result is 24 bytes" ] ], 
  object := [ 24, 12 ] )
]]>
</Example>

Service provider can build some clients function on top of this functionality
and offer them to client, for example, the client can read the function

<Example>
<![CDATA[
IdGroupWS:=function( G )
local H, result;
if not IsPermGroup(G) then
  H:= Image( IsomorphismPermGroup( G ) );
else
  H := G;
fi;  
result := EvaluateBySCSCP ( "GroupIdentificationService", 
            [ GeneratorsOfGroup(H) ], "localhost", 26133 );
return result.object;
end;
]]>
</Example>

and then use it similarly to the <Ref BookName="ref" Func="IdGroup" />:

<Example>
<![CDATA[
gap> G:=DihedralGroup(64);
<pc group of size 64 with 6 generators>
gap> IdGroupWS(G);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
[ 64, 52 ]
]]>
</Example>

<ManSection>
   <Func Name="TerminateProcess" 
          Arg="process"
         Comm="" />
   <Description>
        The function is supposed to send the interrupt signal to the server.
        Current implementation works only when the server is running on the
        same machine with the client, and sends a <C>SIGINT</C> to the server 
        using its PID contained in the <A>process</A>.
        <!-- TODO: check, improve, update. How it works remotely? --> 
   </Description>
</ManSection>

</Section>


<Section Label="Remote">
<Heading>Remote objects</Heading>

<!-- TODO: implement and document store per session / persistently --> 

The &SCSCP; package introduces new kind of objects - <E>remote objects</E>.
They provide an opportunity to manipulate with objects on remote services
without their actual transmitting over the network. Remote objects store
the information that allows to access the original object: the server name 
and the port number through which the object can be accessed, and the variable
name under which it is stored in the remote system. Two remote objects are
equal if and only if all these three parameters coincide.

<ManSection>
    <Func Name="StoreAsRemoteObject" 
           Arg="obj server port"
          Comm="" />
    <Returns>
      remote object
    </Returns>	 
    <Description>
      Returns the remote object corresponding to the object created at
      <A>server</A><C>:</C><A>port</A> from the &OpenMath; representation
      of the first argument <A>obj</A>.
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> s:=StoreAsRemoteObject( SymmetricGroup(3), "localhost", 26133 );
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
< remote object TEMPVarSCSCP@localhost:26133 >
]]>
</Example>

The remote object carries the information that is necessary to access 
the original object: its identifier, server and port:

<Example>
<![CDATA[
gap> s![1]; 
"TEMPVarSCSCP"
gap> s![2];
"localhost"
gap> s![3];
26133
]]>
</Example>

When the remote object is printed in the &OpenMath; format, we
use symbols <C>@</C> and <C>:</C> to combine these parameters
in the &OpenMath; reference:

<Example>
<![CDATA[
gap> OMPrint(s);
<OMOBJ>
	<OMR xref="TEMPVarSCSCP@localhost:26133" />
</OMOBJ>
]]>
</Example>

This allows substritution of remote object as arguments into procedure calls 
in the same manner like we do this with usual objects:

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133);  
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26133:6726" ] ] )
]]>
</Example>


<ManSection>
    <Filt Name="IsRemoteObject" />
    <Description>
    This is the category of remote objects.
    </Description>
</ManSection>


<ManSection>
    <Fam Name="RemoteObjectsFamily" />
    <Description>
    This is the familty of remote objects.
    </Description>
</ManSection>


<ManSection>
    <Func Name="RetrieveRemoteObject" 
           Arg="remoteobject"
          Comm="" />
    <Returns>
      remote object
    </Returns>	 
    <Description>
      This function retrieves the remote object from the remote service
      in the &OpenMath; format and constructs it locally. Note, however,
      that default &OpenMath; representation may not contain all information
      about the object which was accumulated at the time in the remote service.
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> RetrieveRemoteObject(s);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
Group([ (1,2,3), (1,2) ])
]]>
</Example>

<ManSection>
    <Func Name="UnbindRemoteObject" 
           Arg="remoteobject"
          Comm="" />
    <Returns>
      <K>true</K> or <K>false</K>
    </Returns>	 
    <Description>
       Removes any value currently bound to the global variable 
       determined by <A>remoteobject</A>, and returns <K>true</K> or
       <K>false</K> dependently on whether this action was successful
       or not. 
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> UnbindRemoteObject(s);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
true
]]>
</Example>

Finally, we show an example when first we create a group on the service running on 
port 26133, and then identify it on the service running on port 26134. Instead
of transmitting the group to the client and then sending it as an argument to
the second service, the latter service directly retrieves the group from the
first service.

<Example>
<![CDATA[
gap> s:=StoreAsRemoteObject( SymmetricGroup(3), "localhost", 26133 );< remote object TEMPVarSCSCP@localhost:26133 >gap> EvaluateBySCSCP( "WS_IdGroup", [ s ], "localhost", 26134 );rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26134:7414" ] ] )
]]>
</Example>

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133 : output:="cookie" );
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := < remote object TEMPVarSCSCP2@localhost:26133 >, 
  attributes := [ [ "call_id", "localhost:26133:7328" ] ] )
]]>
</Example>

</Section>

</Chapter>