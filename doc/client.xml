<!-- $Id$ -->

<Chapter Label="ClientFunctionality">
<Heading>Client's functionality</Heading>    

<Section Label="Client">
<Heading>Sending request and getting result</Heading>

<ManSection>
   <Func Name="NewProcess" 
          Arg="command listargs server port"
         Comm="" />
   <Returns>
     stream
   </Returns>	 
   <Description>
     <A>command</A> and <C>server</C> are strings, <A>listargs</A>
     is a list of &GAP; objects and <C>port</C> is an integer.
     Calls the SCSCP procedure with the name <A>command</A> 
     and the list of arguments <A>listargs</A> at the server and port
     given by <C>server</C> and <C>port</C>. Returns the stream in
     the category <C>IsInputOutputTCPStream</C> for the subsequent
     waiting the result from that stream.
     <!-- TODO: describe options --> 
   </Description>
</ManSection>

<ManSection>
   <Func Name="CompleteProcess" 
          Arg="stream"
         Comm="" />
   <Returns>
     record with components <C>object</C> and <C>attributes</C> 
   </Returns>	 
   <Description>
     The function waits, if necessary, until the stream will contain
     some data, then reads appropriate &OpenMath; object from the stream
     and closes the stream;
     <!-- TODO: describe options --> 
   </Description>
</ManSection>

In the following example we demonstrate combination of the two previous
functions to send request and get result, calling the procedure, installed 
in the previous chapter: 

<Example>
<![CDATA[
gap> s := NewProcess( "WS_factorial", [10], "localhost", 26133 );                  
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
< process at localhost:26133 pid=6543 >
gap> x := CompleteProcess(s);
rec( object := "3628800", attributes := [ [ "call_id", "localhost:26133:6543" ] ] )
]]>
</Example>

The next function combines the two previous functions, performing both
sending request and getting result in one call.

<ManSection>
   <Func Name="EvaluateBySCSCP" 
          Arg="command listargs server port"
         Comm="" />
   <Returns>
     record with components <C>object</C> and <C>attributes</C> 
   </Returns>	 
   <Description>
     <A>command</A> and <C>server</C> are strings, <A>listargs</A>
     is a list of &GAP; objects and <C>port</C> is an integer.
     Calls the SCSCP procedure with the name <A>command</A> 
     and the list of arguments <A>listargs</A> at the server and port
     given by <C>server</C> and <C>port</C>.
     <!-- TODO: describe options --> 
   </Description>
</ManSection>

<Example>
<![CDATA[
gap> EvaluateBySCSCP( "WS_factorial",[10],"localhost",26133);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := "3628800", attributes := [ [ "call_id", "localhost:26133:6543" ] ] )
]]>
</Example>

Now we demonstrate the procedure <C>GroupIdentificationService</C>,
also given in the previous chapter:

<Example>
<![CDATA[
gap> G:=SymmetricGroup(4);
Sym( [ 1 .. 4 ] )
gap> gens:=GeneratorsOfGroup(G);
[ (1,2,3,4), (1,2) ]
gap> EvaluateBySCSCP( "GroupIdentificationService",[gens],"localhost",26133);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := [ 24, 12 ], attributes := [ [ "call_id", "localhost:26133:6543" ] ] )
]]>
</Example>

Service provider can build some clients function on top of this functionality
and offer them to client, for example, the client can read the function

<Example>
<![CDATA[
IdGroupWS:=function( G )
local H, result;
if not IsPermGroup(G) then
  H:= Image( IsomorphismPermGroup( G ) );
else
  H := G;
fi;  
result := EvaluateBySCSCP ( "GroupIdentificationService", 
            [ GeneratorsOfGroup(H) ], "localhost", 26133 );
return result.object;
end;
]]>
</Example>

and then use it in the following way:

<Example>
<![CDATA[
gap> G:=DihedralGroup(64);
<pc group of size 64 with 6 generators>
gap> IdGroupWS(G);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
[ 64, 52 ]
]]>
</Example>

<ManSection>
   <Func Name="TerminateProcess" 
          Arg="stream"
         Comm="" />
   <Description>
        The function is supposed to send the interrupt signal to the server.
        Now it just closes the stream on the client side, while the server will
        recognize this only when the computation will be completed. In fact,
        closing stream too early (for example, when server writes to it) even
        causes server crash because of the broken pipe. We introduce this 
        function as a nameplace for further implementing a proper interrupt
        mechanism.
        <!-- TODO: check and update description --> 
   </Description>
</ManSection>

</Section>


<Section Label="Remote">
<Heading>Remote objects</Heading>

<!-- TODO: implement and describe store per session / persistently --> 

The &SCSCP; package introduces new kind of objects - <E>remote objects</E>.
They provide an opportunity to manipulate with objects on remote services
without their actual transmitting over the network. Remote objects store
the information that allows to access the original object: the server name 
and the port number through which the object can be accessed, and the variable
name under which it is stored in the remote system. Two remote objects are
equal if and only if all these three parameters coincide.

<ManSection>
    <Func Name="StoreAsRemoteObject" 
           Arg="obj server port"
          Comm="" />
    <Returns>
      remote object
    </Returns>	 
    <Description>
      Returns the remote object corresponding to the object created at
      <A>server</A><C>:</C><A>port</A> from the &OpenMath; representation
      of the first argument <A>obj</A>.
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> s:=StoreAsRemoteObject( SymmetricGroup(3), "localhost", 26133 );
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
< remote object TEMPVarSCSCP@localhost:26133 >
]]>
</Example>

The remote object carries the information that is necessary to access 
the original object: its identifier, server and port:

<Example>
<![CDATA[
gap> s![1]; 
"TEMPVarSCSCP"
gap> s![2];
"localhost"
gap> s![3];
26133
]]>
</Example>

When the remote object is printed in the &OpenMath; format, we
use symbols <C>@</C> and <C>:</C> to combine these parameters
in the &OpenMath; reference:

<Example>
<![CDATA[
gap> OMPrint(s);
<OMOBJ>
	<OMR xref="TEMPVarSCSCP@localhost:26133" />
</OMOBJ>
]]>
</Example>

This allows substritution of remote object as arguments into procedure calls 
in the same manner like we do this with usual objects:

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133);  
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26133:6726" ] ] )
]]>
</Example>


<ManSection>
    <Filt Name="IsRemoteObject" 
           Arg="remoteobject"
          Comm="" />
    <Returns>
      true or false
    </Returns>	 
    <Description>
    <!-- TODO: write this -->
    </Description>
</ManSection>


<ManSection>
    <Fam Name="RemoteObjectsFamily" 
          Comm="" />
    <Description>
    <!-- TODO: write this -->
    </Description>
</ManSection>


<ManSection>
    <Func Name="RetrieveRemoteObject" 
           Arg="remoteobject"
          Comm="" />
    <Returns>
      remote object
    </Returns>	 
    <Description>
      This function retrieves the remote object from the remote service
      in the &OpenMath; format and constructs it locally. Note, however,
      that default &OpenMath; representation may not contain all information
      about the object which was accumulated at the time in the remote service.
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> RetrieveRemoteObject(s);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
Group([ (1,2,3), (1,2) ])
]]>
</Example>

<ManSection>
    <Func Name="UnbindRemoteObject" 
           Arg="remoteobject"
          Comm="" />
    <Returns>
      <K>true</K> or <K>false</K>
    </Returns>	 
    <Description>
       Removes any value currently bound to the global variable 
       determined by <A>remoteobject</A>, and returns <K>true</K> or
       <K>false</K> dependently on whether this action was successful
       or not. 
    </Description>
</ManSection>

<Example>
<![CDATA[
gap> UnbindRemoteObject(s);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
true
]]>
</Example>

Finally, we show an example when first we create a group on the service running on 
port 26133, and then identify it on the service running on port 26134. Instead
of transmitting the group to the client and then sending it as an argument to
the second service, the latter service directly retrieves the group from the
first service.

<Example>
<![CDATA[
gap> s:=StoreAsRemoteObject( SymmetricGroup(3), "localhost", 26133 );< remote object TEMPVarSCSCP@localhost:26133 >gap> EvaluateBySCSCP( "WS_IdGroup", [ s ], "localhost", 26134 );rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26134:7414" ] ] )
]]>
</Example>

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133 : return_cookie);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := < remote object TEMPVarSCSCP2@localhost:26133 >, 
  attributes := [ [ "call_id", "localhost:26133:7328" ] ] )
]]>
</Example>

</Section>

</Chapter>