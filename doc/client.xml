<Chapter Label="ClientFunctionality">
<Heading>Client's functionality</Heading>    

Sending and getting requests to the &SCSCP; server(s),
the client operates with processes. Process is an abstraction 
which in other words may be also called a remote task. It encapsulates
an input/output TCP stream (see <Ref Filt="IsInputOutputTCPStream" />) 
from the client to the server and the process ID of the CAS running 
as a server (deduced from the connection initiation message; may be 
unassigned, if the server CAS did not communicate it).
<P/>
There are two ways to create processes. One of them is to specify
the hostname and port where the &SCSCP; server is running; in this 
case a new input/output TCP stream will be created. Another way is 
first to establish the connection with the &SCSCP; server using
<Ref Func="NewSCSCPconnection" /> and then keep it alive across
multiple remote procedure calls, thus saving time on the DNS lookup 
and connection initiation. This may give a good speedup in computations
with an intensive message exchange. Note that as long as such connection
is open, other &SCSCP; clients will not be able to get through, so
if several clients are interchanging with the &SCSCP; server at the 
same time, they should not block each other with long-lasting connections.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Section Label="SCSCP Connections">
<Heading>&SCSCP; connections</Heading>

<#Include Label="IsSCSCPconnection"/>
<#Include Label="NewSCSCPconnection"/>
<#Include Label="CloseSCSCPconnection"/>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Section Label="Client">
<Heading>Processes</Heading>

<#Include Label="IsProcess"/>
<#Include Label="NewProcess"/>
<#Include Label="CompleteProcess"/>
<#Include Label="TerminateProcess"/>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Section Label="All-in-one">
<Heading>All-in-one: sending request and getting result</Heading>

<#Include Label="EvaluateBySCSCP"/>

Now we demonstrate the procedure <C>GroupIdentificationService</C>,
also given in the previous chapter:

<Example>
<![CDATA[
gap> G:=SymmetricGroup(4);
Sym( [ 1 .. 4 ] )
gap> gens:=GeneratorsOfGroup(G);
[ (1,2,3,4), (1,2) ]
gap> EvaluateBySCSCP( "GroupIdentificationService", [ gens ],
>                     "localhost", 26133 : debuglevel:=3 ); 
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message
#I  Requesting version 1.3 from the server ...
#I  Server confirmed version 1.3 to the client ...
#I  Request sent ...
#I  Waiting for reply ...
rec( attributes := [ [ "call_id", "localhost:26133:2442:xOilXtnw" ], 
      [ "info_runtime", 6 ], [ "info_memory", 670175232 ], 
      [ "info_message", "Memory usage for the result is 24 bytes" ] ], 
  object := [ 24, 12 ] )
]]>
</Example>

Service provider may suggest to the client to use a counterpart function

<Example>
<![CDATA[
IdGroupWS:=function( G )
local H, result;
if not IsPermGroup(G) then
  H:= Image( IsomorphismPermGroup( G ) );
else
  H := G;
fi;  
result := EvaluateBySCSCP ( "GroupIdentificationService", 
            [ GeneratorsOfGroup(H) ], "localhost", 26133 );
return result.object;
end;
]]>
</Example>

which works exactly like <Ref BookName="ref" Func="IdGroup" />:

<Example>
<![CDATA[
gap> G:=DihedralGroup(64);
<pc group of size 64 with 6 generators>
gap> IdGroupWS(G);
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
[ 64, 52 ]
]]>
</Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Section Label="Remote">
<Heading>Remote objects</Heading>

The &SCSCP; package introduces new kind of objects - <E>remote objects</E>.
They provide an opportunity to manipulate with objects on remote services
without their actual transmitting over the network. Remote objects store
the information that allows to access the original object: the server name 
and the port number through which the object can be accessed, and the variable
name under which it is stored in the remote system. Two remote objects are
equal if and only if all these three parameters coincide.
<P/>

There are two types of remote object which differ by their lifetime: 
<List>
<Item>temporary remote objects which exist only within a single session;</Item>
<Item>persistent remote objects which stay alive across multiple sessions.</Item>
</List>

First we show the example of the temporary remote object in a session. The
procedure <C>PointImages</C> returns the set of images of a point <M>i</M>
under the generators of the group <M>G</M>. First we create the symmetric
group <M>S_3</M> on the client and store it remotely on the server 
(call 1), then we compute set of images for <M>i=1,2</M> (calls 2,3) and 
finally demonstrate that we may retrieve the group from the server (call 4):

<Example>
<![CDATA[
gap> stream:=InputOutputTCPStream( "localhost", 26133 );
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
< input/output TCP stream to localhost:26133 >
gap> StartSCSCPsession(stream);
#I  Got connection initiation message
#I  Requesting version 1.3 from the server ...
#I  Server confirmed version 1.3 to the client ...
"localhost:26133:6184"
gap> OMPutProcedureCall( stream, "store_session", 
>       rec( object := [ SymmetricGroup(3) ], 
>        attributes := [ [ "call_id", "1" ], 
>                        ["option_return_cookie"] ] ) );
true
gap> SCSCPwait( stream );
gap> G:=OMGetObjectWithAttributes( stream ).object;
< remote object TEMPVarSCSCPoS5nhta3@localhost:26133 >
gap> OMPutProcedureCall( stream, "PointImages", 
>       rec( object := [ G, 1 ], 
>        attributes := [ [ "call_id", "2" ] ] ) );
true
gap> SCSCPwait( stream );
gap> OMGetObjectWithAttributes( stream );
rec( attributes := [ [ "call_id", "2" ] ], object := [ 2 ] )
gap> OMPutProcedureCall( stream, "PointImages", 
>       rec( object := [ G, 2 ], 
>        attributes := [ [ "call_id", "3" ] ] ) );
true
gap> SCSCPwait( stream );
gap> OMGetObjectWithAttributes( stream );
rec( attributes := [ [ "call_id", "3" ] ], object := [ 1, 3 ] )
gap> OMPutProcedureCall( stream, "retrieve", 
>       rec( object := [ G ], 
>        attributes := [ [ "call_id", "4" ] ] ) );
true
gap> SCSCPwait( stream );
gap> OMGetObjectWithAttributes( stream );
rec( attributes := [ [ "call_id", "4" ] ], 
  object := Group([ (1,2,3), (1,2) ]) )
gap> CloseStream(stream);
]]>
</Example>

After the stream is closed, it is no longer possible to retrieve the
group <M>G</M> again or use it as an argument.
<P/>

Thus, the usage of remote objects existing during a session reduces the
network traffic, since we pass only references instead of actual &OpenMath;
representation of an object. Also, the remote object on the server may
accumulate certain information in its properties and attributes, which may
not be included in it default &OpenMath; representation.
<P/>

Now we show remote objects which remain alive after the session is
closed. Such remote objects may be accessed later, for example, by:
<List>
<Item>subsequent procedure calls from the same instance of &GAP; or another system;</Item>
<Item>other instances of &GAP; or another systems (if the identifier of an object is known)</Item>
<Item>another &SCSCP; servers which obtained a reference to such object as an argument of a procedure call.</Item>
</List>

<#Include Label="StoreAsRemoteObject"/>

Internally, the remote object carries all the information which is required 
to get access to the original object: its identifier, server and port:

<Example>
<![CDATA[
gap> s![1]; 
"TEMPVarSCSCP"
gap> s![2];
"localhost"
gap> s![3];
26133
]]>
</Example>

When the remote object is printed in the &OpenMath; format, we
use symbols <C>@</C> and <C>:</C> to combine these parameters
in the &OpenMath; reference:

<Example>
<![CDATA[
gap> OMPrint(s);
<OMOBJ>
	<OMR xref="TEMPVarSCSCP@localhost:26133" />
</OMOBJ>
]]>
</Example>

This allows substitution of remote object as arguments into procedure calls 
in the same manner like we do this with usual objects:

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133);  
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26133:6726" ] ] )
]]>
</Example>

<#Include Label="IsRemoteObject"/>
<#Include Label="RemoteObjectsFamily"/>
<#Include Label="RetrieveRemoteObject"/>
<#Include Label="UnbindRemoteObject"/>

Finally, we show an example when first we create a group on the service
running on port 26133, and then identify it on the service running on port
26134. Instead of transmitting the group to the client and then sending it
as an argument to the second service, the latter service directly retrieves
the group from the first service.

<Example>
<![CDATA[
gap> s:=StoreAsRemoteObject( SymmetricGroup(3), "localhost", 26133 );
< remote object TEMPVarSCSCP@localhost:26133 >
gap> EvaluateBySCSCP( "WS_IdGroup", [ s ], "localhost", 26134 );
rec( object := [ 6, 1 ], attributes := [ [ "call_id", "localhost:26134:7414" ] ] )
]]>
</Example>

<Example>
<![CDATA[
gap> EvaluateBySCSCP("WS_IdGroup",[s],"localhost",26133 : output:="cookie" );
#I  Creating a socket ...
#I  Connecting to a remote socket via TCP/IP ...
#I  Got connection initiation message 
#I  Request sent ...
#I  Waiting for reply ...
rec( object := < remote object TEMPVarSCSCP2@localhost:26133 >, 
  attributes := [ [ "call_id", "localhost:26133:7328" ] ] )
]]>
</Example>

</Section>

</Chapter>