#############################################################################
##
#W todo.g                   The SCSCP package             Alexander Konovalov
#W                                                               Steve Linton
##
#H $Id$
##
#############################################################################


#############################################################################
1.Early development notes (in case of discrepancies, rather trust the manual)
#############################################################################

The GAP package "SCSCP" has two main components:

1) GAP Server
2) GAP Client

Description:

1) GAP Server is started from the GAP session or during GAP startup.
During GAP Server startup it:
* loads all functions which has to be acessible as SCSCP services
* loads lookup mechanisms for them
* starts to listen specified port (default 26133, as registered by IANA)

For example, the service provider can write a file "myservice.g" looking like:

LoadPackage("scscp");
InstallSCSCPprocedure("factorial", Factorial, ["integer"],  
    "computes factorials of positive integers");
.....
InstallSCSCPprocedure("Simplify", OM-Simplify, ["raw-openmath"],
    "does some special simplification of OpenMath objects");
    
RunSCSCPserver( "servername", portnumber );

After this to start the GAP server it remains to do 

gap myservice.g

RunSCSCPserver:
* accepts connection from client via port 26133
* performs an exchange of connection initionation messages with the client
* sends, if requested, the meta-information about provided services
* starts read-evaluate-write loop:
  - obtains OM message "procedure_call"
  - performs lookup of the appropriate GAP function and checks all input,
    with the message "procedure_terminated" if this step fails
  - starts computation, during which it controls GAP and returns 
    "procedure_terminated" message if:
    a) interrupt sygnal was obtained
    b) system is out of resources (in multiuser mode the limits may be 
       specified by WS provider and the user may not have control over them, 
       in single-user they must be specified by the user within bounds
       specified by WS provider)
    c) computation was terminated by GAP:
       - Error message with brk> loop (how can we catch this? are we
         going two run an interface from GAP to GAP??? Can/should we 
         manage to do this within single copy of the system? This 
         must be possible, provided sygnal kernel and time-space
         limits control will be implemented in the kernel)
       - system crash (in this case the client detects broken connection,
         and eventually we may want some way to start new GAP server process
         automatically in this case, but anyway there is no point to try to
         pick up the ongoing session)
  - if none of this was happened, returns the result in the form of the 
    "procedure_completed" message and returns to the beginning of
    read-evaluate-print loop

In a multi-user mode it never stops until it will be terminated by the service
provider. Multi-user mode is intended to perform single quickly computed requests.
Thus, on each iteration SCSCP server accepts next request from the queue. 

In a single user mode for each client there is one copy of GAP. This can be 
reduced to multi-user mode, if the client will be able to launch GAP SCSCP 
wrapper which will create its personal SCSCP service (Can we do this???). 
That SCSCP service will be stopped by the client's initiative or under some 
other specified conditions to prevent forgotten jobs from infinite running.
    
3) GAP Client (to connect to SCSCP server):
* establishes connection with the SCSCP server via the specified port 
* performs an exchange of connection initionation messages with the server
* requests, if necessary, the meta-information about provided services
* starts exchange loop:
  - sends OM message "procedure_call"
  - waits for the result of computation, and while waiting it must be able
    to send the interrupt sygnal in case of timeout
  - analyze the returned result and continues in case of "procedure_completed" 
    or leave the loop in case of "procedure_terminated"

#############################################################################
2.RELEASE HOW-TO
#############################################################################

* replace paths from my local machine to something more neutral in:
  - gapd.sh
  
* remove example/private.g file  
* remove lines for loading example/private.g file from example/myserver.g

  

#############################################################################
3.TODO
#############################################################################

* Separate store per session/persistently
* Really disable heads which are not allowed (allow to turn this on/off?)
* Implement all bussiness with signatures 
* Revise interrupts and other processing instructions

* An idea we might consider in the future: change the structure of OMsymRecord 
to cd.symbol.method, cd.symbol.role etc, then transient CD record could me 
merged with OMsymRecord. Storing cd.symbol.role may be useful, for example,
GetAllowedHeads then will be able to select only OMA.