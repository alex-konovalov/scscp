#############################################################################
##
#W todo.g                   The SCSCP package             Alexander Konovalov
#W                                                               Steve Linton
##
#H $Id: $
##
#############################################################################

The GAP package with the provisional name "SCSCP" has two main components:

1) GAP Server
2) GAP Client

Description:

1) GAP Server is started from the GAP session or during GAP startup.
During GAP Server startup it:
* loads all functions which has to be acessible via WS
* loads lookup mechanisms for them
* creates WS description as a WSDL message
* starts to listen specified port (e.g. 26133)

For example, service provider can write a file "myservice.g" looking like:

LoadPackage("scscp");
InstallSCSCPprocedure("factorial", Factorial, ["integer"],  
    "computes factorials of positive integers");
.....
InstallSCSCPprocedure("Simplify", OM-Simplify, ["raw-openmath"],
    "does some special simplification of OpenMath objects");
RunSCSCPserver( "servername", portnumber );

After this to start the GAP server it remains to do 

gap myservice.g

RunSCSCPserver:
* accepts connection from client via port 26133
* sends to client a connection information message in the format
  "SCSCP_VERSION 1 CAS_PID xxxx + zero byte"
* sends a List of Supported Procedures message in WSDL  
* starts read-evaluate-write loop:
  - obtains OM message "procedure_call"
  - performs lookup of the appropriate GAP function and checks all input,
    with the message "procedure_terminated" if this step fails
  - starts computation, during which it controls GAP and returns 
    "procedure_terminated" message if:
    a) interrupt sygnal was obtained
    b) system is out of resources (in multiuser mode the limits may be 
       specified by WS provider and the user may not have control over them, 
       in single-user they must be specified by the user within bounds
       specified by WS provider)
    c) computation was terminated by GAP:
       - Error message with brk> loop (how can we catch this? are we
         going two run an interface from GAP to GAP??? Can/should we 
         manage to do this within single copy of the system? This 
         must be possible, provided sygnal kernel and time-space
         limits control will be implemented in the kernel)
       - system crash (in this case the client detects broken connection,
         and eventually we may want some way to start new GAP server process
         automatically in this case, but anyway there is no point to try to
         pick up the ongoing session)
  - if none of this was happened, returns the result in the form of the 
    "procedure_completed" message and returns to the beginning of
    read-evaluate-print loop

In a multi-user mode it never stops until it will be terminated by the WS 
provider. Multi-user mode is intended to perform single quickly computed requests.
Thus, on each iteration WS accepts next request from the queue. 

In a single user mode for each client there is one copy of GAP. This can be 
reduced to multi-user mode, if the client will be able to launch GAP WS Wrapper
which will create its personal WS (Can we do this???). The WS will be stopped
when the client will enter appropriate command e.g. QUIT_WS (that must be 
provided by WS and included in WSDL message), or under some other specified 
conditions to prevent forgotten jobs from infinite running.
    
3) GAP Client (to connect to GAP WS and other WS):
- establish connection with WS with the specified port (we can easily use GAP
  WS in development, but we should keep in mind that it must be compatible 
  with other WS from systems participating in the SCIEnce project)
- receives a connection information message in the format
  "SCSCP_VERSION 1 CAS_PID xxxx + zero byte"
* receives a List of Supported Procedures message in WSDL 
  and performs certain analysis of it
* starts exchange loop:
  - sends OM message "procedure_call"
  - waits for the result of computation, and while waiting it must be able
    to send the interrupt sygnal in case of timeout
  - analyze the returned result and continues in case of "procedure_completed" 
    or leave the loop in case of "procedure_terminated"